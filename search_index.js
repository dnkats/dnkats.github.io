var documenterSearchIndex = {"docs":
[{"location":"tensortools/#Tensor-tools","page":"Tensor tools","title":"Tensor tools","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"ElemCo.TensorTools","category":"page"},{"location":"tensortools/#ElemCo.TensorTools","page":"Tensor tools","title":"ElemCo.TensorTools","text":"tensor tools,      e.g., access to integrals, load/save intermediates... \n\n\n\n\n\n","category":"module"},{"location":"tensortools/#I/O-functions","page":"Tensor tools","title":"I/O functions","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"ElemCo.save\nElemCo.load\nElemCo.mmap\nElemCo.newmmap\nElemCo.closemmap","category":"page"},{"location":"tensortools/#ElemCo.TensorTools.save","page":"Tensor tools","title":"ElemCo.TensorTools.save","text":"save(EC::ECInfo, fname::String, a::AbstractArray, descr=\"tmp\"; overwrite=true)\n\nSave array a to file fname in EC.scr directory.   Add file to EC.files with description descr.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.load","page":"Tensor tools","title":"ElemCo.TensorTools.load","text":"load(EC::ECInfo, fname::String)\n\nLoad array from file fname in EC.scr directory.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.mmap","page":"Tensor tools","title":"ElemCo.TensorTools.mmap","text":"mmap(EC::ECInfo, fname::String)\n\nMemory-map an existing file for reading.   Return a pointer to the file and the mmaped array.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.newmmap","page":"Tensor tools","title":"ElemCo.TensorTools.newmmap","text":"newmmap(EC::ECInfo, fname::String, Type, dims::Tuple{Vararg{Int}}, descr=\"tmp\")\n\nCreate a new memory-map file for writing (overwrites existing file).   Add file to EC.files with description descr.   Return a pointer to the file and the mmaped array.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.closemmap","page":"Tensor tools","title":"ElemCo.TensorTools.closemmap","text":"closemmap(EC::ECInfo, file, array)\n\nClose memory-map file and flush to disk.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#Integral-extraction","page":"Tensor tools","title":"Integral extraction","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"ElemCo.ints1\nElemCo.ints2","category":"page"},{"location":"tensortools/#ElemCo.TensorTools.ints1","page":"Tensor tools","title":"ElemCo.TensorTools.ints1","text":"ints1(EC::ECInfo, spaces::String, spincase = nothing)\n\nReturn subset of 1e⁻ integrals according to spaces. \n\nThe spincase∈{:α,:β} can explicitly be given, or will be deduced    from upper/lower case of spaces specification. \n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.ints2","page":"Tensor tools","title":"ElemCo.TensorTools.ints2","text":"ints2(EC::ECInfo, spaces::String, spincase = nothing, detri = true)\n\nReturn subset of 2e⁻ integrals according to spaces. \n\nThe spincase∈{:α,:β} can explicitly be given, or will be deduced    from upper/lower case of spaces specification.   If the last two indices are stored as triangular and detri - make them full,   otherwise return as a triangular cut.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#Tensor-manipulation","page":"Tensor tools","title":"Tensor manipulation","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"ElemCo.sqrtinvchol\nElemCo.invchol\nElemCo.rotate_eigenvectors_to_real!","category":"page"},{"location":"tensortools/#ElemCo.TensorTools.sqrtinvchol","page":"Tensor tools","title":"ElemCo.TensorTools.sqrtinvchol","text":"sqrtinvchol(A::AbstractMatrix; tol = 1e-8, verbose = false)\n\nReturn NON-SYMMETRIC (pseudo)sqrt-inverse of a hermitian matrix using Cholesky decomposition.\n\nStarting from A^{-1} = A^{-1} L (A^{-1} L)† = M M†   with A = L L†.   By solving the equation L† M = I (for low-rank: using QR decomposition).   Return M\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.invchol","page":"Tensor tools","title":"ElemCo.TensorTools.invchol","text":"invchol(A::AbstractMatrix; tol = 1e-8, verbose = false)\n\nReturn (pseudo)inverse of a hermitian matrix using Cholesky decomposition .\n\nA^-1 = A^-1 L (A^-1 L)† = M M†   with A = L L†.   By solving the equation L† M = I (for low-rank: using QR decomposition) \n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.rotate_eigenvectors_to_real!","page":"Tensor tools","title":"ElemCo.TensorTools.rotate_eigenvectors_to_real!","text":"rotate_eigenvectors_to_real!(evecs::AbstractMatrix, evals::AbstractVector)\n\nIn-place transform complex eigenvectors of a real matrix to a real space    such that they block-diagonalize the matrix.\n\n\n\n\n\n","category":"function"},{"location":"fockfactory/#Fock-builders","page":"Fock builders","title":"Fock builders","text":"","category":"section"},{"location":"fockfactory/","page":"Fock builders","title":"Fock builders","text":"ElemCo.FockFactory\nElemCo.FockFactory.gen_fock\nElemCo.FockFactory.gen_ufock\nElemCo.FockFactory.gen_dffock\nElemCo.FockFactory.gen_density_matrix","category":"page"},{"location":"fockfactory/#ElemCo.FockFactory","page":"Fock builders","title":"ElemCo.FockFactory","text":"Fock builders (using FciDump or DF integrals) \n\n\n\n\n\n","category":"module"},{"location":"fockfactory/#ElemCo.FockFactory.gen_fock","page":"Fock builders","title":"ElemCo.FockFactory.gen_fock","text":"gen_fock(EC::ECInfo)\n\nCalculate closed-shell fock matrix from FCIDump integrals. \n\n\n\n\n\ngen_fock(EC::ECInfo, spincase::Symbol)\n\nCalculate UHF fock matrix from FCIDump integrals for spincase∈{:α,:β}. \n\n\n\n\n\ngen_fock(EC::ECInfo, CMOl::AbstractArray, CMOr::AbstractArray)\n\nCalculate closed-shell fock matrix from FCIDump integrals and orbitals CMOl, CMOr. \n\n\n\n\n\ngen_fock(EC::ECInfo, spincase::Symbol, CMOl::AbstractArray, CMOr::AbstractArray)\n\nCalculate UHF fock matrix from FCIDump integrals for spincase∈{:α,:β} and orbitals CMOl, CMOr and   orbitals for the opposite-spin CMOlOS and CMOrOS. \n\n\n\n\n\n","category":"function"},{"location":"fockfactory/#ElemCo.FockFactory.gen_ufock","page":"Fock builders","title":"ElemCo.FockFactory.gen_ufock","text":"gen_ufock(EC::ECInfo, CMOl::AbstractArray, CMOr::AbstractArray)\n\nCalculate UHF fock matrix from FCIDump integrals and orbitals cMOl, cMOr   with cMOl[1] and cMOr[1] - α-MO transformation coefficients and    cMOl[2] and cMOr[2] - β-MO transformation coefficients. \n\n\n\n\n\n","category":"function"},{"location":"fockfactory/#ElemCo.FockFactory.gen_dffock","page":"Fock builders","title":"ElemCo.FockFactory.gen_dffock","text":"gen_dffock(EC::ECInfo, cMO::AbstractArray, bao, bfit)\n\nCompute closed-shell DF-HF Fock matrix (integral direct) in AO basis.\n\n\n\n\n\ngen_dffock(EC::ECInfo, cMO::AbstractArray)\n\nCompute closed-shell DF-HF Fock matrix in AO basis   (using precalculated Cholesky-decomposed integrals).\n\n\n\n\n\n","category":"function"},{"location":"fockfactory/#ElemCo.FockFactory.gen_density_matrix","page":"Fock builders","title":"ElemCo.FockFactory.gen_density_matrix","text":"gen_density_matrix(EC::ECInfo, CMOl::AbstractArray, CMOr::AbstractArray, occvec)\n\nGenerate D{μν}=C^l{μi} C^r_{νi} with i defined by occvec   Only real part of D is kept.\n\n\n\n\n\n","category":"function"},{"location":"elemco/#Calculations","page":"Calculations","title":"Calculations","text":"","category":"section"},{"location":"elemco/#Macros","page":"Calculations","title":"Macros","text":"","category":"section"},{"location":"elemco/","page":"Calculations","title":"Calculations","text":"@ECsetup\n@tryECsetup\n@opt\n@dfhf\n@dfints\n@cc\n@run","category":"page"},{"location":"elemco/#ElemCo.@ECsetup","page":"Calculations","title":"ElemCo.@ECsetup","text":"@ECsetup()\n\nSetup EC::ECInfo from variables geometry::String and basis::Dict{String,Any}.\n\nExamples\n\ngeometry=\"\nHe 0.0 0.0 0.0\"\nbasis = Dict(\"ao\"=>\"cc-pVDZ\", \"jkfit\"=>\"cc-pvtz-jkfit\", \"mp2fit\"=>\"cc-pvdz-rifit\")\n@ECsetup\n# output\nOccupied orbitals:[1]\n\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@tryECsetup","page":"Calculations","title":"ElemCo.@tryECsetup","text":"@tryECsetup()\n\nSetup EC::ECInfo from geometry::String and basis::Dict{String,Any}    if not already done.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@opt","page":"Calculations","title":"ElemCo.@opt","text":"@opt(what, kwargs...)\n\nSet options for EC::ECInfo. \n\nIf EC is not already setup, it will be done. \n\nExamples\n\n@opt scf thr=1.e-14 maxit=10\n@opt cc maxit=100\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@dfhf","page":"Calculations","title":"ElemCo.@dfhf","text":"@dfhf()\n\nRun DFHF calculation and return MO coefficients (ORBS) and orbital energies (EPS).\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@dfints","page":"Calculations","title":"ElemCo.@dfints","text":"@dfints(orbs = nothing, fcidump = \"\")\n\nGenerate 2 and 4-idx MO integrals using density fitting.\n\nIf orbs::Matrix is given, the orbitals are used to generate the integrals,    otherwise the last orbitals (ORBS) are used.   If fcidump::String is given, the integrals are written to the fcidump file.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@cc","page":"Calculations","title":"ElemCo.@cc","text":"@cc(method, kwargs...)\n\nRun coupled cluster calculation.\n\nThe type of the method is determined by the first argument (ccsd/ccsd(t)/dcsd etc)\n\nKeyword arguments\n\nfcidump::String: fcidump file (default: \"\", i.e., use integrals from EC).\nocca::String: occupied α orbitals (default: \"-\").\noccb::String: occupied β orbitals (default: \"-\").\n\nExamples\n\ngeometry=\"bohr\nO      0.000000000    0.000000000   -0.130186067\nH1     0.000000000    1.489124508    1.033245507\nH2     0.000000000   -1.489124508    1.033245507\"\nbasis = Dict(\"ao\"=>\"cc-pVDZ\", \"jkfit\"=>\"cc-pvtz-jkfit\", \"mp2fit\"=>\"cc-pvdz-rifit\")\n@dfhf\n@dfints\n@cc ccsd\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@run","page":"Calculations","title":"ElemCo.@run","text":"general runner \n\n\n\n\n\n","category":"macro"},{"location":"elemco/#Exported-functions","page":"Calculations","title":"Exported functions","text":"","category":"section"},{"location":"elemco/","page":"Calculations","title":"Calculations","text":"ECdriver","category":"page"},{"location":"elemco/#ElemCo.ECdriver","page":"Calculations","title":"ElemCo.ECdriver","text":"ECdriver(EC::ECInfo, methods; fcidump=\"FCIDUMP\", occa=\"-\", occb=\"-\")\n\nRun electronic structure calculation for EC::ECInfo using methods methods::String.\n\nThe integrals are read from fcidump::String (default: \"FCIDUMP\").   If fcidump::String is empty, the integrals from EC.fd are used.   The occupied α orbitals are given by occa::String (default: \"-\").   The occupied β orbitals are given by occb::String (default: \"-\").   If occb::String is empty, the occupied β orbitals are the same as the occupied α orbitals (closed-shell case).\n\n\n\n\n\n","category":"function"},{"location":"elemco/#Some-internal-functions","page":"Calculations","title":"Some internal functions","text":"","category":"section"},{"location":"elemco/","page":"Calculations","title":"Calculations","text":"ElemCo.parse_commandline\nElemCo.is_closed_shell\nElemCo.calc_HF_energy","category":"page"},{"location":"elemco/#ElemCo.parse_commandline","page":"Calculations","title":"ElemCo.parse_commandline","text":"parse_commandline(EC::ECInfo)\n\nParse command line arguments. \n\n\n\n\n\n","category":"function"},{"location":"elemco/#ElemCo.is_closed_shell","page":"Calculations","title":"ElemCo.is_closed_shell","text":"is_closed_shell(EC::ECInfo)\n\nCheck if the system is closed-shell    according the to the reference occupation and FCIDump.\n\n\n\n\n\n","category":"function"},{"location":"elemco/#ElemCo.calc_HF_energy","page":"Calculations","title":"ElemCo.calc_HF_energy","text":"calc_HF_energy(EC::ECInfo, closed_shell)\n\nCalculate HF energy from FCIDump and EC info. \n\n\n\n\n\n","category":"function"},{"location":"dfhf/#Density-fitted-Hartree-Fock","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"","category":"section"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"The density-fitted Hartree-Fock (DF-HF) method is a method for computing the Hartree-Fock energy using density fitting. The DF-HF method is implemented in ElemCo.jl using the @dfhf macro. Here's an example of how you can use this macro:","category":"page"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"using ElemCo\n\n# Define the molecule\ngeometry=\"bohr\n     O      0.000000000    0.000000000   -0.130186067\n     H1     0.000000000    1.489124508    1.033245507\n     H2     0.000000000   -1.489124508    1.033245507\"\n\nbasis = Dict(\"ao\"=>\"cc-pVDZ\",\n             \"jkfit\"=>\"cc-pvtz-jkfit\",\n             \"mp2fit\"=>\"cc-pvdz-rifit\")\n\n# Compute DF-HF\n@dfhf","category":"page"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"This code defines a water molecule, computes DF-HF using the cc-pVDZ basis set, and calculates the DF-HF energy.","category":"page"},{"location":"dfhf/#Exported-functions-and-types","page":"Density-fitted Hartree-Fock","title":"Exported functions and types","text":"","category":"section"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"ElemCo.dfhf","category":"page"},{"location":"dfhf/#ElemCo.DFHF.dfhf","page":"Density-fitted Hartree-Fock","title":"ElemCo.DFHF.dfhf","text":"dfhf(EC::ECInfo; direct=false, guess=:SAD)\n\nPerform closed-shell DF-HF calculation.\n\n\n\n\n\n","category":"function"},{"location":"orbtools/#Orbital-tools","page":"Orbital tools","title":"Orbital tools","text":"","category":"section"},{"location":"orbtools/#Exported-functions","page":"Orbital tools","title":"Exported functions","text":"","category":"section"},{"location":"orbtools/","page":"Orbital tools","title":"Orbital tools","text":"ElemCo.OrbTools.guess_orb","category":"page"},{"location":"orbtools/#ElemCo.OrbTools.guess_orb","page":"Orbital tools","title":"ElemCo.OrbTools.guess_orb","text":"guess_orb(EC::ECInfo, guess::Symbol)\n\nCalculate starting guess for MO coefficients.   Type of initial guess for MO coefficients is given by guess.\n\nPossible values:\n\n:HCORE from core Hamiltonian\n:SAD from atomic densities\n:GWH not implemented yet\n:ORB from previous orbitals stored in file EC.options.scf.orbsguess\n\n\n\n\n\n","category":"function"},{"location":"orbtools/#Internal-functions","page":"Orbital tools","title":"Internal functions","text":"","category":"section"},{"location":"orbtools/","page":"Orbital tools","title":"Orbital tools","text":"ElemCo.OrbTools.guess_hcore\nElemCo.OrbTools.guess_sad","category":"page"},{"location":"orbtools/#ElemCo.OrbTools.guess_hcore","page":"Orbital tools","title":"ElemCo.OrbTools.guess_hcore","text":"guess_hcore(EC::ECInfo)\n\nGuess MO coefficients from core Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"orbtools/#ElemCo.OrbTools.guess_sad","page":"Orbital tools","title":"ElemCo.OrbTools.guess_sad","text":"guess_sad(EC::ECInfo)\n\nGuess MO coefficients from atomic densities.\n\n\n\n\n\n","category":"function"},{"location":"diis/#DIIS-solver","page":"DIIS solver","title":"DIIS solver","text":"","category":"section"},{"location":"diis/","page":"DIIS solver","title":"DIIS solver","text":"ElemCo.DIIS","category":"page"},{"location":"diis/#ElemCo.DIIS","page":"DIIS solver","title":"ElemCo.DIIS","text":"DIIS module for iterative solvers\n\n\n\n\n\n","category":"module"},{"location":"diis/#Main-structure","page":"DIIS solver","title":"Main structure","text":"","category":"section"},{"location":"diis/","page":"DIIS solver","title":"DIIS solver","text":"ElemCo.DIIS.Diis","category":"page"},{"location":"diis/#ElemCo.DIIS.Diis","page":"DIIS solver","title":"ElemCo.DIIS.Diis","text":"DIIS object\n\n\n\n\n\n","category":"type"},{"location":"diis/#Exported-functions","page":"DIIS solver","title":"Exported functions","text":"","category":"section"},{"location":"diis/","page":"DIIS solver","title":"DIIS solver","text":"ElemCo.DIIS.perform","category":"page"},{"location":"diis/#ElemCo.DIIS.perform","page":"DIIS solver","title":"ElemCo.DIIS.perform","text":"perform(diis::Diis, Amps, Res)\n\nPerform DIIS.\n\n\n\n\n\n","category":"function"},{"location":"dump/#FCIDump-files","page":"FCIDump files","title":"FCIDump files","text":"","category":"section"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"ElemCo.FciDump","category":"page"},{"location":"dump/#ElemCo.FciDump","page":"FCIDump files","title":"ElemCo.FciDump","text":"Read and write fcidump format integrals. Individual arrays of integrals can also be in *.npy format\n\n\n\n\n\n","category":"module"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"The FCIDump file format is a simple text file format for storing molecular integrals. It is used by many quantum chemistry programs. ","category":"page"},{"location":"dump/#Storage-of-molecular-integrals","page":"FCIDump files","title":"Storage of molecular integrals","text":"","category":"section"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"ElemCo.FDump","category":"page"},{"location":"dump/#ElemCo.FciDump.FDump","page":"FCIDump files","title":"ElemCo.FciDump.FDump","text":"FDump\n\nMolecular integrals \n\nThe 2-e integrals are stored in the physicists' notation: int2[pqrs] = <pq|rs>   and for triang the last two indices are stored as a single upper triangular index (r <= s)\n\nint2:  2-e⁻ integrals for restricted orbitals fcidump.  Default: []\nint2aa:  αα 2-e⁻ integrals for unrestricted orbitals fcidump.  Default: []\nint2bb:  ββ 2-e⁻ integrals for unrestricted orbitals fcidump.  Default: []\nint2ab:  αβ 2-e⁻ integrals for unrestricted orbitals fcidump.  Default: []\nint1:  1-e⁻ integrals for restricted orbitals fcidump.  Default: []\nint1a:  α 1-e⁻ integrals for unrestricted orbitals fcidump.  Default: []\nint1b:  β 1-e⁻ integrals for unrestricted orbitals fcidump.  Default: []\nint0:  core energy  Default: 0.0\nhead:  header of fcidump file, a dictionary of arrays.  Default: Dict()\ntriang:  use an upper triangular index for last two indices of 2e⁻ integrals. Default: true\nuhf:  a convinience variable, has to coincide with head[\"IUHF\"][1] > 0.  Default: false\n\n\n\n\n\n","category":"type"},{"location":"dump/#Exported-functions","page":"FCIDump files","title":"Exported functions","text":"","category":"section"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"ElemCo.read_fcidump\nElemCo.write_fcidump\nElemCo.fd_exists\nElemCo.transform_fcidump\nElemCo.headvar\nElemCo.integ1\nElemCo.integ2\nElemCo.uppertriangular\nElemCo.uppertriangular_range","category":"page"},{"location":"dump/#ElemCo.FciDump.read_fcidump","page":"FCIDump files","title":"ElemCo.FciDump.read_fcidump","text":"read_fcidump(fcidump::String)\n\nRead ascii file (possibly with integrals in npy files).\n\n\n\n\n\n","category":"function"},{"location":"dump/#ElemCo.FciDump.write_fcidump","page":"FCIDump files","title":"ElemCo.FciDump.write_fcidump","text":"write_fcidump(fd::FDump, fcidump::String, tol=1e-12)\n\nWrite fcidump file.\n\n\n\n\n\n","category":"function"},{"location":"dump/#ElemCo.FciDump.fd_exists","page":"FCIDump files","title":"ElemCo.FciDump.fd_exists","text":"fd_exists(fd::FDump)\n\nReturn true if the object is a non-empty FDump\n\n\n\n\n\n","category":"function"},{"location":"dump/#ElemCo.FciDump.transform_fcidump","page":"FCIDump files","title":"ElemCo.FciDump.transform_fcidump","text":"transform_fcidump(fd::FDump, Tl::AbstractArray, Tr::AbstractArray)\n\nTransform integrals to new basis using Tl and Tr transformation matrices.    For UHF fcidump, Tl and Tr are arrays of matrices for α and β spin.   If Tl and Tr are arrays of arrays, then the function transforms rhf fcidump to uhf fcidump.\n\n\n\n\n\n","category":"function"},{"location":"dump/#ElemCo.FciDump.headvar","page":"FCIDump files","title":"ElemCo.FciDump.headvar","text":"headvar(head::Dict, key::String)\n\nCheck header for key, return value if a list,    or the element or nothing if not there.\n\n\n\n\n\nheadvar(fd::FDump, key::String)\n\nCheck header for key, return value if a list,    or the element or nothing if not there.\n\n\n\n\n\n","category":"function"},{"location":"dump/#ElemCo.FciDump.integ1","page":"FCIDump files","title":"ElemCo.FciDump.integ1","text":"integ1(fd::FDump, spincase::Symbol=:α)\n\nReturn 1-e⁻ integrals (for UHF fcidump: for spincase).   spincase can be :α or :β.\n\n\n\n\n\n","category":"function"},{"location":"dump/#ElemCo.FciDump.integ2","page":"FCIDump files","title":"ElemCo.FciDump.integ2","text":"integ2(fd::FDump, spincase::Symbol=:α)\n\nReturn 2-e⁻ integrals (for UHF fcidump: for spincase).   spincase can be :α, :β or :αβ.\n\n\n\n\n\n","category":"function"},{"location":"dump/#ElemCo.FciDump.uppertriangular","page":"FCIDump files","title":"ElemCo.FciDump.uppertriangular","text":"uppertriangular(i1, i2)\n\nReturn upper triangular index from two indices i1 <= i2.\n\n\n\n\n\nuppertriangular(i1, i2, i3)\n\nReturn upper triangular index from three indices i1 <= i2 <= i3.\n\n\n\n\n\n","category":"function"},{"location":"dump/#ElemCo.FciDump.uppertriangular_range","page":"FCIDump files","title":"ElemCo.FciDump.uppertriangular_range","text":"uppertriangular_range(i2)\n\nReturn range for the upper triangular index (i1 <= i2) for a given i2. \n\n\n\n\n\n","category":"function"},{"location":"dfdump/#Generation-of-integrals-using-density-fitting","page":"Generation of integrals using density fitting","title":"Generation of integrals using density fitting","text":"","category":"section"},{"location":"dfdump/","page":"Generation of integrals using density fitting","title":"Generation of integrals using density fitting","text":"ElemCo.DfDump","category":"page"},{"location":"dfdump/#ElemCo.DfDump","page":"Generation of integrals using density fitting","title":"ElemCo.DfDump","text":"generate fcidump using df integrals and store in dumpfile \n\n\n\n\n\n","category":"module"},{"location":"dfdump/#Exported-functions","page":"Generation of integrals using density fitting","title":"Exported functions","text":"","category":"section"},{"location":"dfdump/","page":"Generation of integrals using density fitting","title":"Generation of integrals using density fitting","text":"ElemCo.dfdump","category":"page"},{"location":"dfdump/#ElemCo.DfDump.dfdump","page":"Generation of integrals using density fitting","title":"ElemCo.DfDump.dfdump","text":"dfdump(EC::ECInfo, cMO, dumpfile = \"FCIDUMP\")\n\nGenerate fcidump using df integrals and store in dumpfile.   If dumpfile is empty, don't write to fcidump file, store in EC.fd.\n\n\n\n\n\n","category":"function"},{"location":"dfdump/#Internal-functions","page":"Generation of integrals using density fitting","title":"Internal functions","text":"","category":"section"},{"location":"dfdump/","page":"Generation of integrals using density fitting","title":"Generation of integrals using density fitting","text":"ElemCo.DfDump.generate_integrals","category":"page"},{"location":"dfdump/#ElemCo.DfDump.generate_integrals","page":"Generation of integrals using density fitting","title":"ElemCo.DfDump.generate_integrals","text":"generate_integrals(EC::ECInfo, fdump::FDump, cMO)\n\nGenerate int2, int1 and int0 integrals for fcidump.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"ElemCo.Utils\nElemCo.Utils.print_time","category":"page"},{"location":"utils/#ElemCo.Utils","page":"Utils","title":"ElemCo.Utils","text":"various utilities \n\n\n\n\n\n","category":"module"},{"location":"utils/#ElemCo.Utils.print_time","page":"Utils","title":"ElemCo.Utils.print_time","text":"print_time(EC::AbstractECInfo, t1, info::AbstractString, verb::Int)\n\nPrint time with message info if verbosity verb is smaller than EC.verbosity.\n\n\n\n\n\n","category":"function"},{"location":"dfcc/#Density-fitted-Coupled-Cluster-methods","page":"Density-fitted Coupled Cluster methods","title":"Density-fitted Coupled Cluster methods","text":"","category":"section"},{"location":"dfcc/","page":"Density-fitted Coupled Cluster methods","title":"Density-fitted Coupled Cluster methods","text":"ElemCo.DFCoupledCluster","category":"page"},{"location":"dfcc/#ElemCo.DFCoupledCluster","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster","text":"DFCoupledCluster\n\nDensity-fitted coupled-cluster methods.\n\n\n\n\n\n","category":"module"},{"location":"dfcc/#Exported-functions","page":"Density-fitted Coupled Cluster methods","title":"Exported functions","text":"","category":"section"},{"location":"dfcc/","page":"Density-fitted Coupled Cluster methods","title":"Density-fitted Coupled Cluster methods","text":"ElemCo.DFCoupledCluster.calc_dressed_3idx\nElemCo.DFCoupledCluster.calc_svd_dcsd_residual","category":"page"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_dressed_3idx","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_dressed_3idx","text":"calc_dressed_3idx(EC,T1)\n\nCalculate dressed integrals for 3-index integrals from file pqP.\n\n\n\n\n\n","category":"function"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_svd_dcsd_residual","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_svd_dcsd_residual","text":"calc_svd_dcsd_residual(EC::ECInfo, T1, T2_XY)\n\nCalculate decomposed closed-shell DCSD residual with   T^ij_ab=U^iX_a U^jY_b T_XY and   R_XY=U^iX_a U^jY_b R^ij_ab.\n\n\n\n\n\n","category":"function"},{"location":"msystem/#Molecular-system","page":"Molecular system","title":"Molecular system","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The molecular system is the core of the simulation. It contains all the information about the molecule, including the geometry and basis sets The molecular system is defined using the MSys function:","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"MSys(geometry, basis)","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"where geometry is a string containing the molecular geometry in the XYZ format, and basis is a dictionary containing the basis set information.","category":"page"},{"location":"msystem/#Geometry","page":"Molecular system","title":"Geometry","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The geometry of the molecule is defined using the geometry argument of the MSys function. The geometry is defined in the XYZ format. Here's an example of how you can define the geometry of a water molecule:","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"geometry=\"bohr\n     O      0.000000000    0.000000000   -0.130186067\n     H1     0.000000000    1.489124508    1.033245507\n     H2     0.000000000   -1.489124508    1.033245507\"","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The first line of the geometry string contains the units of the coordinates. The supported units are bohr and angstrom. The coordinates of the atoms are specified in the following lines. Each line contains the atomic symbol and the coordinates of the atom. The coordinates are separated by spaces or tabs.","category":"page"},{"location":"msystem/#Basis-set","page":"Molecular system","title":"Basis set","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The basis set is defined using the basis argument of the MSys function. The basis set is defined as a dictionary, where the keys are the names of the basis sets, and the values are the basis set definitions. Here's an example of how you can define the basis set for a water molecule:","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"basis = Dict(\"ao\"=>\"cc-pVDZ\",\n             \"jkfit\"=>\"cc-pvtz-jkfit\",\n             \"mp2fit\"=>\"cc-pvdz-rifit\")","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The basis set dictionary contains three keys: ao, jkfit, and mp2fit. The ao key contains the basis set for the AO integrals, the jkfit key contains the basis set for the density fitting integrals in the Hartree-Fock calculations, and the mp2fit key contains the fitting basis set for the correlated calculations.","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"ElemCo.MSystem","category":"page"},{"location":"msystem/#ElemCo.MSystem","page":"Molecular system","title":"ElemCo.MSystem","text":"Info about molecular system (geometry/basis).\n\n\n\n\n\n","category":"module"},{"location":"msystem/#Exported-functions-and-types","page":"Molecular system","title":"Exported functions and types","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"ElemCo.MSys\nElemCo.ms_exists\nElemCo.Basis\nElemCo.ACenter\nElemCo.genxyz\nElemCo.nuclear_repulsion\nElemCo.bond_length\nElemCo.electron_distribution\nElemCo.guess_nelec\nElemCo.guess_norb\nElemCo.generate_basis","category":"page"},{"location":"msystem/#ElemCo.MSystem.MSys","page":"Molecular system","title":"ElemCo.MSystem.MSys","text":"Geometry and basis set for each element name in the geometry\n\natoms: array of atomic centers.\n\n\n\n\n\n","category":"type"},{"location":"msystem/#ElemCo.MSystem.ms_exists","page":"Molecular system","title":"ElemCo.MSystem.ms_exists","text":"ms_exists(ms::MSys)\n\nCheck whether the system is not empty.\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.Basis","page":"Molecular system","title":"ElemCo.MSystem.Basis","text":"Basis set\n\nname:  e.g., vdz, cc-pvdz, aug-cc-pvdz, cc-pvdz-jkfit.\n\n\n\n\n\n","category":"type"},{"location":"msystem/#ElemCo.MSystem.ACenter","page":"Molecular system","title":"ElemCo.MSystem.ACenter","text":"Atomic center\n\nname: name (as defined in input).\nnuccharge: nuclear charge (can be changed...).\ncoord: coordinates in bohr.\nbasis: various basis sets (ao,mp2fit,jkfit).\n\n\n\n\n\n","category":"type"},{"location":"msystem/#ElemCo.MSystem.genxyz","page":"Molecular system","title":"ElemCo.MSystem.genxyz","text":"genxyz(ac::ACenter; bohr=true)\n\nGenerate xyz string with element without numbers.   If bohr: return in coordinates in bohr.\n\n\n\n\n\ngenxyz(ms::MSys; bohr=true)\n\nGenerate xyz string with elements without numbers.   If bohr: return in coordinates in bohr\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.nuclear_repulsion","page":"Molecular system","title":"ElemCo.MSystem.nuclear_repulsion","text":"nuclear_repulsion(ms::MSys)\n\nCalculate nuclear repulsion energy.\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.bond_length","page":"Molecular system","title":"ElemCo.MSystem.bond_length","text":"bond_length(cen1::ACenter, cen2::ACenter)\n\nCalculate bond length between two centers.\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.electron_distribution","page":"Molecular system","title":"ElemCo.MSystem.electron_distribution","text":"electron_distribution(elem::AbstractString, nsh4l::Vector{Int})\n\nDistribute electrons among first atomic orbitals in nsh4l[1]s nsh4l[2]p nsh4l[3]d nsh4l[4]f... order   considering the Hund's rule and electron configuration of the atom.   Average occupations to account for the spin degeneracy and hybridization.\n\n\n\n\n\nelectron_distribution(elnam::AbstractString, minbas::AbstractString)\n\nReturn the averaged number of electrons in the orbitals in the minimal basis set.\n\nNumber of orbitals in the minimal basis set has to be specified in minbas.jl.\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.guess_nelec","page":"Molecular system","title":"ElemCo.MSystem.guess_nelec","text":"guess_nelec(ms::MSys)\n\nGuess the number of electrons in the neutral system.\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.guess_norb","page":"Molecular system","title":"ElemCo.MSystem.guess_norb","text":"guess_norb(ms::MSys)\n\nGuess the number of orbitals in the system.\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.generate_basis","page":"Molecular system","title":"ElemCo.MSystem.generate_basis","text":"generate_basis(ms::MSys, type = \"ao\")\n\nGenerate basis sets for integral calculations.   type can be \"ao\", \"mp2fit\" or \"jkfit\".\n\n\n\n\n\n","category":"function"},{"location":"mnpy/#Memory-maping-of-NPY-files","page":"Memory-maping of NPY files","title":"Memory-maping of NPY files","text":"","category":"section"},{"location":"mnpy/","page":"Memory-maping of NPY files","title":"Memory-maping of NPY files","text":"ElemCo.MNPY.mnpymmap","category":"page"},{"location":"mnpy/#ElemCo.MNPY.mnpymmap","page":"Memory-maping of NPY files","title":"ElemCo.MNPY.mnpymmap","text":"mnpymmap(filename::AbstractString)\n\nMmap a variable from filename.  The input needs to be an npy file.\n\nnote: Zero-dimensional arrays\nZero-dimensional arrays are stripped while being read in, and the values that they contain are returned. This is a notable difference from numpy, where  numerical values are written out and read back in as zero-dimensional arrays.\n\nExamples\n\njulia> using NPZ\njulia> npzwrite(\"temp.npy\", ones(3))\njulia> mnpymmap(\"temp.npy\") # Mmaps the variable\n3-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n\n\n\n\n\n","category":"function"},{"location":"bohf/#Bi-orthogonal-Hartree-Fock","page":"Bi-orthogonal Hartree-Fock","title":"Bi-orthogonal Hartree-Fock","text":"","category":"section"},{"location":"bohf/","page":"Bi-orthogonal Hartree-Fock","title":"Bi-orthogonal Hartree-Fock","text":"ElemCo.BOHF","category":"page"},{"location":"bohf/#ElemCo.BOHF","page":"Bi-orthogonal Hartree-Fock","title":"ElemCo.BOHF","text":"bi-orthogonal Hartree-Fock method     (using a similarity-transformed FciDump)\n\n\n\n\n\n","category":"module"},{"location":"bohf/#Exported-functions","page":"Bi-orthogonal Hartree-Fock","title":"Exported functions","text":"","category":"section"},{"location":"bohf/","page":"Bi-orthogonal Hartree-Fock","title":"Bi-orthogonal Hartree-Fock","text":"ElemCo.BOHF.bohf\nElemCo.BOHF.bouhf","category":"page"},{"location":"bohf/#ElemCo.BOHF.bohf","page":"Bi-orthogonal Hartree-Fock","title":"ElemCo.BOHF.bohf","text":"bohf(EC::ECInfo)\n\nPerform BO-HF using integrals from fcidump EC.fd.\n\n\n\n\n\n","category":"function"},{"location":"bohf/#ElemCo.BOHF.bouhf","page":"Bi-orthogonal Hartree-Fock","title":"ElemCo.BOHF.bouhf","text":"bouhf(EC::ECInfo)\n\nPerform BO-UHF using integrals from fcidump EC.fd.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.jl-global-information","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"ElemCo.ECInfos\nElemCo.ECInfo\nElemCo.setup!\nElemCo.set_options!\nElemCo.parse_orbstring\nElemCo.get_occvirt\nElemCo.n_occ_orbs\nElemCo.n_occb_orbs\nElemCo.n_virt_orbs\nElemCo.n_virtb_orbs\nElemCo.n_orbs","category":"page"},{"location":"ecinfos/#ElemCo.ECInfos","page":"ElemCo.jl global information","title":"ElemCo.ECInfos","text":"Various global infos \n\n\n\n\n\n","category":"module"},{"location":"ecinfos/#ElemCo.ECInfos.ECInfo","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.ECInfo","text":"ECInfo\n\nGlobal information for ElemCo.\n\nscr:  path to scratch directory.  Default: joinpath(tempdir(), \"elemcojlscr\")\next:  extension of temporary files.  Default: .bin\nout:  output file.  Default:\nverbosity:  verbosity level.  Default: 2\noptions:  options.  Default: Options()\nms:  molecular system.  Default: MSys()\nfd:  fcidump.  Default: FDump()\nfiles:  information about (temporary) files. The naming convention is: prefix_ + name (+extension EC.ext added automatically). prefix can be:\nd for dressed integrals\nS for overlap matrix\nf for Fock matrix\ne for orbital energies\nD for density matrix\nh for core Hamiltonian\nC for transformation from one basis to another\nname is given by the subspaces involved:\no for occupied\nv for virtual\nO for occupied-β\nV for virtual-β\nm for (full) MO space\nM for (full) β-MO space\nA for AO basis\na for active orbitals\nc for closed-shell (doubly-occupied) orbitals\nP for auxiliary orbitals (fitting basis)\nL for auxiliary orbitals (Cholesky decomposition, orthogonal)\nX for auxiliary orbitals (amplitudes decomposition)\nDefault: Dict{String, String}()\nignore_error:  ignore various errors.  Default: false\nspace:  subspaces: 'o'ccupied, 'v'irtual, 'O'ccupied-β, 'V'irtual-β, ':' general.  Default: Dict{Char, Any}()\n\n\n\n\n\n","category":"type"},{"location":"ecinfos/#ElemCo.ECInfos.setup!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.setup!","text":"setup!(EC::ECInfo; fcidump=\"\", occa=\"-\", occb=\"-\", nelec=0, charge=0, ms2=0)\n\nSetup ECInfo from fcidump or molecular system.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.set_options!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.set_options!","text":"set_options!(opt; kwargs...)\n\nSet options for option opt using keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.parse_orbstring","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.parse_orbstring","text":"parse_orbstring(orbs::String; orbsym = Vector{Int})\n\nParse a string specifying some list of orbitals, e.g.,    -3+5-8+10-12 → [1 2 3 5 6 7 8 10 11 12]   or use ':' and ';' instead of '-' and '+', respectively.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.get_occvirt","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.get_occvirt","text":"get_occvirt(EC::ECInfo, occas::String, occbs::String, norb, nelec; ms2=0, orbsym = Vector{Int})\n\nUse a +/- string to specify the occupation. If occbs==\"-\", the occupation from occas is used (closed-shell).   If both are \"-\", the occupation is deduced from nelec and ms2.   The optional argument orbsym is a vector with length norb of orbital symmetries (1 to 8) for each orbital.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.n_occ_orbs","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.n_occ_orbs","text":"n_occ_orbs(EC::ECInfo)\n\nReturn number of occupied orbitals (for UHF: α).\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.n_occb_orbs","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.n_occb_orbs","text":"n_occb_orbs(EC::ECInfo)\n\nReturn number of occupied orbitals (β).\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.n_virt_orbs","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.n_virt_orbs","text":"n_virt_orbs(EC::ECInfo)\n\nReturn number of virtual orbitals (for UHF: α).\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.n_virtb_orbs","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.n_virtb_orbs","text":"n_virtb_orbs(EC::ECInfo)\n\nReturn number of virtual orbitals (β).\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.n_orbs","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.n_orbs","text":"n_orbs(EC::ECInfo)\n\nReturn number of orbitals.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#File-management","page":"ElemCo.jl global information","title":"File management","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"ElemCo.file_exists\nElemCo.add_file\nElemCo.delete_temporary_files","category":"page"},{"location":"ecinfos/#ElemCo.ECInfos.file_exists","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.file_exists","text":"file_exists(EC::ECInfo, name::String)\n\nCheck if file name exists in ECInfo.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.add_file","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.add_file","text":"add_file(EC::ECInfo, name::String, descr::String; overwrite = false)\n\nAdd file name to ECInfo with (space-separated) descriptions descr.   Possible description: tmp (temporary).\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.delete_temporary_files","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.delete_temporary_files","text":"delete_temporary_files(EC::ECInfo)\n\nDelete all temporary files in ECInfo.  \n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#Abstract-types","page":"ElemCo.jl global information","title":"Abstract types","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"ElemCo.AbstractEC","category":"page"},{"location":"ecinfos/#ElemCo.AbstractEC","page":"ElemCo.jl global information","title":"ElemCo.AbstractEC","text":"Abstract types to resolve circular dependencies\n\n\n\n\n\n","category":"module"},{"location":"ecinfos/#Internal-functions","page":"ElemCo.jl global information","title":"Internal functions","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"ElemCo.ECInfos.symorb2orb","category":"page"},{"location":"ecinfos/#ElemCo.ECInfos.symorb2orb","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.symorb2orb","text":"symorb2orb(symorb::SubString, symoffset::Vector{Int})\n\nConvert a symorb (like 1.3 [orb.sym]) to an orbital number.   If no sym given, just return the orbital number converted to Int.\n\n\n\n\n\n","category":"function"},{"location":"dfmcscf/#MCSCF-program","page":"MCSCF program","title":"MCSCF program","text":"","category":"section"},{"location":"dfmcscf/#Exported-functions","page":"MCSCF program","title":"Exported functions","text":"","category":"section"},{"location":"dfmcscf/","page":"MCSCF program","title":"MCSCF program","text":"ElemCo.DFMCSCF.dfmcscf\nElemCo.DFMCSCF.davidson","category":"page"},{"location":"dfmcscf/#ElemCo.DFMCSCF.dfmcscf","page":"MCSCF program","title":"ElemCo.DFMCSCF.dfmcscf","text":"dfmcscf(EC::ECInfo; direct = false, guess=:SAD, IterMax=50)\n\nMain body of Density-Fitted Multi-Configurational Self-Consistent-Field method\n\n\n\n\n\n","category":"function"},{"location":"dfmcscf/#ElemCo.DFMCSCF.davidson","page":"MCSCF program","title":"ElemCo.DFMCSCF.davidson","text":"davidson(H::Matrix, N::Integer, n::Integer, thres::Number, convTrack::Bool=false)\n\nCalculate one of the eigenvalues and corresponding eigenvector of the matrix H (usually the lowest eigenvalue),  N is the size of the matrix H,  n is the maximal size of projected matrix,  thres is the criterion of convergence,  convTrack is to decide whether the tracking of eigenvectors is used\n\n\n\n\n\n","category":"function"},{"location":"mio/#I/O-routines","page":"I/O routines","title":"I/O routines","text":"","category":"section"},{"location":"mio/","page":"I/O routines","title":"I/O routines","text":"ElemCo.MIO","category":"page"},{"location":"mio/#ElemCo.MIO","page":"I/O routines","title":"ElemCo.MIO","text":"EC-specific IO routines\n\nUse to store arrays in a file, and to load them back.   Use memory-maps to store and load large arrays.\n\n\n\n\n\n","category":"module"},{"location":"mio/#I/O-functions","page":"I/O routines","title":"I/O functions","text":"","category":"section"},{"location":"mio/","page":"I/O routines","title":"I/O routines","text":"ElemCo.MIO.miosave\nElemCo.MIO.mioload\nElemCo.MIO.miommap\nElemCo.MIO.mionewmmap\nElemCo.MIO.mioclosemmap","category":"page"},{"location":"mio/#ElemCo.MIO.miosave","page":"I/O routines","title":"ElemCo.MIO.miosave","text":"miosave(fname::String,arrs::AbstractArray{T}...) where T\n\nSave arrays arrs in a file fname.\n\n\n\n\n\n","category":"function"},{"location":"mio/#ElemCo.MIO.mioload","page":"I/O routines","title":"ElemCo.MIO.mioload","text":"mioload(fname::String; array_of_arrays = false)\n\nLoad arrays from a file fname.\n\nReturn an array of arrays.   If there is only one array - return array itself   (unless array_of_arrays is set to true).\n\n\n\n\n\n","category":"function"},{"location":"mio/#ElemCo.MIO.miommap","page":"I/O routines","title":"ElemCo.MIO.miommap","text":"miommap(fname::String)\n\nMemory-map an existing file for reading.   Return a pointer to the file and the mmaped array.\n\n\n\n\n\n","category":"function"},{"location":"mio/#ElemCo.MIO.mionewmmap","page":"I/O routines","title":"ElemCo.MIO.mionewmmap","text":"mionewmmap(fname::String, Type, dims::Tuple{Vararg{Int}})\n\nCreate a new memory-map file for writing (overwrites existing file).   Return a pointer to the file and the mmaped array.\n\n\n\n\n\n","category":"function"},{"location":"mio/#ElemCo.MIO.mioclosemmap","page":"I/O routines","title":"ElemCo.MIO.mioclosemmap","text":"mioclosemmap(io::IO, array::AbstractArray)\n\nClose memory-map file and flush to disk.\n\n\n\n\n\n","category":"function"},{"location":"cc/#Coupled-cluster-methods","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"","category":"section"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"ElemCo.CoupledCluster","category":"page"},{"location":"cc/#ElemCo.CoupledCluster","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster","text":"coupled-cluster methods \n\n\n\n\n\n","category":"module"},{"location":"cc/#Exported-functions","page":"Coupled-cluster methods","title":"Exported functions","text":"","category":"section"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"ElemCo.calc_MP2\nElemCo.calc_UMP2\nElemCo.method_name\nElemCo.calc_cc\nElemCo.calc_pertT","category":"page"},{"location":"cc/#ElemCo.CoupledCluster.calc_MP2","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_MP2","text":"calc_MP2(EC::ECInfo)\n\nCalculate closed-shell MP2 energy and amplitudes.    Return (EMp2, T2) \n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_UMP2","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_UMP2","text":"calc_UMP2(EC::ECInfo, addsingles=true)\n\nCalculate unrestricted MP2 energy and amplitudes.    Return (EMp2, T2a, T2b, T2ab)\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.method_name","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.method_name","text":"method_name(T1, dc=false)\n\nGuess method name (CCSD/DCSD/CCD/DCD)\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_cc","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_cc","text":"calc_cc(EC::ECInfo, T1, T2, dc = false)\n\nCalculate closed-shell coupled cluster amplitudes.\n\nIf length(T1) is 0 on input, no singles will be calculated. If dc: calculate distinguishable cluster.\n\n\n\n\n\ncalc_cc(EC::ECInfo, T1a, T1b, T2a, T2b, T2ab, dc = false)\n\nCalculate unrestricted coupled cluster amplitudes.\n\nIf length(T1a) && length(T1b) are 0 on input, no singles will be calculated.   If dc: calculate distinguishable cluster.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_pertT","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_pertT","text":"calc_pertT(EC::ECInfo, T1, T2; save_t3=false)\n\nCalculate (T) correction for closed-shell CCSD.\n\nReturn ( (T)-energy, [T]-energy))\n\n\n\n\n\n","category":"function"},{"location":"cc/#Some-internal-functions","page":"Coupled-cluster methods","title":"Some internal functions","text":"","category":"section"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"ElemCo.CoupledCluster.update_singles\nElemCo.CoupledCluster.update_doubles\nElemCo.CoupledCluster.calc_singles_energy\nElemCo.CoupledCluster.calc_doubles_energy\nElemCo.CoupledCluster.calc_hylleraas\nElemCo.CoupledCluster.calc_singles_norm\nElemCo.CoupledCluster.calc_doubles_norm\nElemCo.CoupledCluster.calc_dressed_ints\nElemCo.CoupledCluster.calc_D2\nElemCo.CoupledCluster.calc_D2a\nElemCo.CoupledCluster.calc_ccsd_resid","category":"page"},{"location":"cc/#ElemCo.CoupledCluster.update_singles","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.update_singles","text":"update_singles(R1, ϵo, ϵv, shift)\n\nCalculate update for singles amplitudes.\n\n\n\n\n\nupdate_singles(EC::ECInfo, R1; spincase::Symbol=:α, use_shift=true)\n\nCalculate update for singles amplitudes for a given spincase∈{:α,:β}.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.update_doubles","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.update_doubles","text":"update_doubles(R2, ϵo1, ϵv1, ϵo2, ϵv2, shift)\n\nCalculate update for doubles amplitudes.\n\n\n\n\n\nupdate_doubles(EC::ECInfo, R2; spincase::Symbol=:α, antisymmetrize=false, use_shift=true)\n\nCalculate update for doubles amplitudes for a given spincase∈{:α,:β,:αβ}.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_singles_energy","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_singles_energy","text":"calc_singles_energy(EC::ECInfo, T1; fock_only=false)\n\nCalculate coupled-cluster closed-shell singles energy.\n\n\n\n\n\ncalc_singles_energy(EC::ECInfo, T1a, T1b; fock_only=false)\n\nCalculate energy for α (T1a) and β (T1b) singles amplitudes.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_doubles_energy","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_doubles_energy","text":"calc_doubles_energy(EC::ECInfo, T2; fock_only=false)\n\nCalculate coupled-cluster closed-shell doubles energy.\n\n\n\n\n\ncalc_doubles_energy(EC::ECInfo, T2a, T2b, T2ab; fock_only=false)\n\nCalculate energy for αα (T2a), ββ (T2b) and αβ (T2ab) doubles amplitudes.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_hylleraas","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_hylleraas","text":"calc_hylleraas(EC::ECInfo, T1, T2, R1, R2)\n\nCalculate closed-shell singles and doubles Hylleraas energy\n\n\n\n\n\ncalc_hylleraas(EC::ECInfo, T1a, T1b, T2a, T2b, T2ab, R1a, R1b, R2a, R2b, R2ab)\n\nCalculate singles and doubles Hylleraas energy.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_singles_norm","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_singles_norm","text":"calc_singles_norm(T1)\n\nCalculate squared norm of closed-shell singles amplitudes.\n\n\n\n\n\ncalc_singles_norm(T1a, T1b)\n\nCalculate squared norm of unrestricted singles amplitudes.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_doubles_norm","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_doubles_norm","text":"calc_doubles_norm(T2)\n\nCalculate squared norm of closed-shell doubles amplitudes.\n\n\n\n\n\ncalc_doubles_norm(T2a, T2b, T2ab)\n\nCalculate squared norm of unrestricted doubles amplitudes.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_dressed_ints","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_dressed_ints","text":"calc_dressed_ints(EC::ECInfo, T1, T12, o1::Char, v1::Char, o2::Char, v2::Char)\n\nDress integrals with singles amplitudes. \n\nThe singles and orbspaces for first and second electron are T1, o1, v1 and T12,o2,v2, respectively.   The integrals from EC.fd are used and dressed integrals are stored asd_????`.\n\n\n\n\n\ncalc_dressed_ints(EC::ECInfo, T1a, T1b=Float64[])\n\nDress integrals with singles.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_D2","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_D2","text":"calc_D2(EC::ECInfo, T1, T2, scalepp = false)\n\nCalculate D^ij_pq = T^ij_cd + T^i_c T^j_d +δ_ik T^j_d + T^i_c δ_jl + δ_ik δ_jl.   Return as D[pqij] \n\nIf scalepp: D[ppij] elements are scaled by 0.5 (for triangular summation).\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_D2a","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_D2a","text":"calc_D2a(EC::ECInfo, T1a, T2a)\n\nCalculate ^ααD^ij_pq = T^ij_cd + P_ij(T^i_c T^j_d +δ_ik T^j_d + T^i_c δ_jl + δ_ik δ_jl)   with P_ij X_ij = X_ij - X_ji.   Return as D[pqij] \n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_ccsd_resid","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ccsd_resid","text":"calc_ccsd_resid(EC::ECInfo, T1, T2, dc)\n\nCalculate CCSD or DCSD closed-shell residual.\n\n\n\n\n\ncalc_ccsd_resid(EC::ECInfo, T1a,T1b,T2a,T2b,T2ab,dc)\n\nCalculate UCCSD or UDCSD residual.\n\n\n\n\n\n","category":"function"},{"location":"options/#Options","page":"Options","title":"Options","text":"","category":"section"},{"location":"options/","page":"Options","title":"Options","text":"ElemCo.ECInfos.Options\nElemCo.ECInfos.ScfOptions\nElemCo.ECInfos.CcOptions\nElemCo.ECInfos.CholeskyOptions\nElemCo.ECInfos.DiisOptions","category":"page"},{"location":"options/#ElemCo.ECInfos.Options","page":"Options","title":"ElemCo.ECInfos.Options","text":"Options for ElemCo.jl\n\nscf:  SCF options.  Default: ScfOptions()\ncc:  Coupled-Cluster options.  Default: CcOptions()\ncholesky:  Cholesky options.  Default: CholeskyOptions()\ndiis:  DIIS options.  Default: DiisOptions()\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.ScfOptions","page":"Options","title":"ElemCo.ECInfos.ScfOptions","text":"Options for SCF calculation\n\nthr:  convergence threshold.  Default: 1.0e-10\nmaxit:  maximum number of iterations.  Default: 50\nimagtol:  tolerance for imaginary part of MO coefs (for biorthogonal).  Default: 1.0e-8\nguess:  orbital guess.  Default: :SAD\norbsguess:  orbitals for orbital guess.  Default: C_Am\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.CcOptions","page":"Options","title":"ElemCo.ECInfos.CcOptions","text":"Options for Coupled-Cluster calculation\n\nthr:  convergence threshold.  Default: 1.0e-10\nmaxit:  maximum number of iterations.  Default: 50\nshifts:  level shift for singles.  Default: 0.15\nshiftp:  level shift for doubles.  Default: 0.2\nshiftt:  level shift for triples.  Default: 0.2\nampsvdtol:  amplitude decomposition threshold.  Default: 0.001\nuse_kext:  use kext for doubles residual.  Default: true\ncalc_d_vvvv:  calculate dressed <vv|vv>.  Default: false\ncalc_d_vvvo:  calculate dressed <vv|vo>.  Default: false\ncalc_d_vovv:  calculate dressed <vo|vv>.  Default: false\ncalc_d_vvoo:  calculate dressed <vv|oo>.  Default: false\ntriangular_kext:  use a triangular kext if possible.  Default: true\ncalc_t3_for_decomposition:  calculate (T) for decomposition.  Default: false\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.CholeskyOptions","page":"Options","title":"ElemCo.ECInfos.CholeskyOptions","text":"Options for Cholesky decomposition.\n\nthr:  cholesky threshold.  Default: 1.0e-6\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.DiisOptions","page":"Options","title":"ElemCo.ECInfos.DiisOptions","text":"Options for DIIS.\n\nmaxdiis:  maximum number of DIIS vectors.  Default: 6\nresthr:  DIIS residual threshold.  Default: 10.0\n\n\n\n\n\n","category":"type"},{"location":"#ElemCo.jl-Documentation","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"","category":"section"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"ElemCo.jl is a Julia package for computing electronic structure properties of molecules and materials. It provides a set of tools for performing quantum chemical calculations, including Hartree-Fock and post-HF methods.","category":"page"},{"location":"#Installation","page":"ElemCo.jl Documentation","title":"Installation","text":"","category":"section"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"You can install ElemCo.jl using the Julia package manager:","category":"page"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"julia> using Pkg\njulia> Pkg.add(\"ElemCo\")","category":"page"},{"location":"#Usage","page":"ElemCo.jl Documentation","title":"Usage","text":"","category":"section"},{"location":"#Computing-density-fitted-Hartree-Fock-and-Coupled-Cluster-methods","page":"ElemCo.jl Documentation","title":"Computing density-fitted Hartree-Fock and Coupled Cluster methods","text":"","category":"section"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"To compute density-fitted Hartree-Fock (DF-HF) using ElemCo.jl, you can use the @dfhf macro. In order to run post-HF calculations, the integrals have to be transformed to the MO basis (using the @dfints macro), and the coupled cluster calculations can be performed using @cc macro. Here's an example of how you can use these macros:","category":"page"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"using ElemCo\n\n# Define the molecule\ngeometry=\"bohr\n     O      0.000000000    0.000000000   -0.130186067\n     H1     0.000000000    1.489124508    1.033245507\n     H2     0.000000000   -1.489124508    1.033245507\"\n\n\nbasis = Dict(\"ao\"=>\"cc-pVDZ\",\n             \"jkfit\"=>\"cc-pvtz-jkfit\",\n             \"mp2fit\"=>\"cc-pvdz-rifit\")\n\n# Compute DF-HF \n@dfhf\n# Calculate MO integrals \n@dfints\n# Run CCSD(T) calculation\n@cc ccsd(t)","category":"page"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"This code defines a water molecule, computes DF-HF using the cc-pVDZ basis set, calculates integrals using density fitting (mp2fit basis) and computes CCSD(T) energy.","category":"page"},{"location":"#Setting-options","page":"ElemCo.jl Documentation","title":"Setting options","text":"","category":"section"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"To set options for the DF-HF calculation, you can use the @opt macro. Here's an example of how you can use this macro:","category":"page"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"# Set the maximum number of iterations to 10\n@opt scf maxit=10\n\n# Compute DF-HF using the new options\n@dfhf","category":"page"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"This code sets the maximum number of iterations for the SCF procedure to 10 using the @opt macro, and then computes DF-HF using the new options using the @dfhf macro.","category":"page"},{"location":"ecmethod/#ElemCo.jl-methods","page":"ElemCo.jl methods","title":"ElemCo.jl methods","text":"","category":"section"},{"location":"ecmethod/","page":"ElemCo.jl methods","title":"ElemCo.jl methods","text":"ElemCo.ECMethods","category":"page"},{"location":"ecmethod/#ElemCo.ECMethods","page":"ElemCo.jl methods","title":"ElemCo.ECMethods","text":"Specify methods available for electron-correlation calculations\n\n\n\n\n\n","category":"module"},{"location":"ecmethod/#Main-structure","page":"ElemCo.jl methods","title":"Main structure","text":"","category":"section"},{"location":"ecmethod/","page":"ElemCo.jl methods","title":"ElemCo.jl methods","text":"ElemCo.ECMethod","category":"page"},{"location":"ecmethod/#ElemCo.ECMethods.ECMethod","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.ECMethod","text":"Description of the electron-correlation method\n\n\n\n\n\n","category":"type"},{"location":"dftools/#Density-fitting-tools","page":"Density-fitting tools","title":"Density-fitting tools","text":"","category":"section"},{"location":"dftools/","page":"Density-fitting tools","title":"Density-fitting tools","text":"ElemCo.DFTools","category":"page"},{"location":"dftools/#ElemCo.DFTools","page":"Density-fitting tools","title":"ElemCo.DFTools","text":"This module contains various utils for density fitting.\n\n\n\n\n\n","category":"module"},{"location":"dftools/#Exported-functions","page":"Density-fitting tools","title":"Exported functions","text":"","category":"section"},{"location":"dftools/","page":"Density-fitting tools","title":"Density-fitting tools","text":"ElemCo.DFTools.generate_AO_DF_integrals\nElemCo.DFTools.generate_DF_integrals","category":"page"},{"location":"dftools/#ElemCo.DFTools.generate_AO_DF_integrals","page":"Density-fitting tools","title":"ElemCo.DFTools.generate_AO_DF_integrals","text":"generate_AO_DF_integrals(EC::ECInfo, fitbasis=\"mp2fit\"; save3idx=true)\n\nGenerate AO integrals using DF + Cholesky.   If save3idx is true, save Cholesky-decomposed 3-index integrals,    otherwise save pseudo-square-root-inverse Cholesky decomposition.\n\n\n\n\n\n","category":"function"},{"location":"dftools/#ElemCo.DFTools.generate_DF_integrals","page":"Density-fitting tools","title":"ElemCo.DFTools.generate_DF_integrals","text":"generate_DF_integrals(EC::ECInfo, cMO)\n\nGenerate v_p^qL, f_p^q and E_{nuc} with   v_pr^qs = v_p^qL 1_LL v_r^sL.   The v_p^qL are generated using mp2fit fitting basis, and   the f_p^q are generated using jkfit fitting basis.   The integrals are stored in files mmL and f_mm.\n\n\n\n\n\n","category":"function"}]
}
