var documenterSearchIndex = {"docs":
[{"location":"msystem/#Molecular-system","page":"Molecular system","title":"Molecular system","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The molecular system is the core of the simulation. It contains all the information about the molecule, including the geometry and basis sets The molecular system is defined using the MSys function:","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"MSys(geometry, basis)","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"where geometry is a string containing the molecular geometry in the XYZ format, and basis is a dictionary containing the basis set information.","category":"page"},{"location":"msystem/#Geometry","page":"Molecular system","title":"Geometry","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The geometry of the molecule is defined using the geometry argument of the MSys function. The geometry is defined in the XYZ format. Here's an example of how you can define the geometry of a water molecule:","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"geometry=\"bohr\n     O      0.000000000    0.000000000   -0.130186067\n     H1     0.000000000    1.489124508    1.033245507\n     H2     0.000000000   -1.489124508    1.033245507\"","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The first line of the geometry string contains the units of the coordinates. The supported units are bohr and angstrom. The coordinates of the atoms are specified in the following lines. Each line contains the atomic symbol and the coordinates of the atom. The coordinates are separated by spaces or tabs.","category":"page"},{"location":"msystem/#Basis-set","page":"Molecular system","title":"Basis set","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The basis set is defined using the basis argument of the MSys function. The basis set is defined as a dictionary, where the keys are the names of the basis sets, and the values are the basis set definitions. Here's an example of how you can define the basis set for a water molecule:","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"basis = Dict(\"ao\"=>\"cc-pVDZ\",\n             \"jkfit\"=>\"cc-pvtz-jkfit\",\n             \"mp2fit\"=>\"cc-pvdz-rifit\")","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The basis set dictionary contains three keys: ao, jkfit, and mp2fit. The ao key contains the basis set for the AO integrals, the jkfit key contains the basis set for the density fitting integrals in the Hartree-Fock calculations, and the mp2fit key contains the fitting basis set for the correlated calculations.","category":"page"},{"location":"msystem/#Exported-functions-and-types","page":"Molecular system","title":"Exported functions and types","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"ElemCo.MSys\nElemCo.ms_exists\nElemCo.Basis\nElemCo.ACenter\nElemCo.genxyz\nElemCo.nuclear_repulsion\nElemCo.bond_length\nElemCo.electron_distribution\nElemCo.guess_nelec\nElemCo.guess_norb","category":"page"},{"location":"msystem/#ElemCo.MSystem.MSys","page":"Molecular system","title":"ElemCo.MSystem.MSys","text":"Geometry and basis set for each element name in the geometry\n\natoms: array of atomic centers.\n\n\n\n\n\n","category":"type"},{"location":"msystem/#ElemCo.MSystem.ms_exists","page":"Molecular system","title":"ElemCo.MSystem.ms_exists","text":"ms_exists(ms::MSys)\n\nCheck whether the system is not empty.\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.Basis","page":"Molecular system","title":"ElemCo.MSystem.Basis","text":"Basis set\n\nname:  e.g., vdz, cc-pvdz, aug-cc-pvdz, cc-pvdz-jkfit.\n\n\n\n\n\n","category":"type"},{"location":"msystem/#ElemCo.MSystem.ACenter","page":"Molecular system","title":"ElemCo.MSystem.ACenter","text":"Atomic center\n\nname: name (as defined in input).\nnuccharge: nuclear charge (can be changed...).\ncoord: coordinates in bohr.\nbasis: various basis sets (ao,mp2fit,jkfit).\n\n\n\n\n\n","category":"type"},{"location":"msystem/#ElemCo.MSystem.genxyz","page":"Molecular system","title":"ElemCo.MSystem.genxyz","text":"genxyz(ac::ACenter; bohr=true)\n\nGenerate xyz string with element without numbers.   If bohr: return in coordinates in bohr.\n\n\n\n\n\ngenxyz(ms::MSys; bohr=true)\n\nGenerate xyz string with elements without numbers.   If bohr: return in coordinates in bohr\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.nuclear_repulsion","page":"Molecular system","title":"ElemCo.MSystem.nuclear_repulsion","text":"nuclear_repulsion(ms::MSys)\n\nCalculate nuclear repulsion energy.\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.bond_length","page":"Molecular system","title":"ElemCo.MSystem.bond_length","text":"bond_length(cen1::ACenter, cen2::ACenter)\n\nCalculate bond length between two centers.\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.electron_distribution","page":"Molecular system","title":"ElemCo.MSystem.electron_distribution","text":"electron_distribution(elem::AbstractString, nsh4l::Vector{Int})\n\nDistribute electrons among first atomic orbitals in nsh4l[1]s nsh4l[2]p nsh4l[3]d nsh4l[4]f... order   considering the Hund's rule and electron configuration of the atom.   Average occupations to account for the spin degeneracy and hybridization.\n\n\n\n\n\nelectron_distribution(elnam::AbstractString, minbas::AbstractString)\n\nReturn the averaged number of electrons in the orbitals in the minimal basis set.\n\nNumber of orbitals in the minimal basis set has to be specified in minbas.jl.\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.guess_nelec","page":"Molecular system","title":"ElemCo.MSystem.guess_nelec","text":"guess_nelec(ms::MSys)\n\nGuess the number of electrons in the neutral system.\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.guess_norb","page":"Molecular system","title":"ElemCo.MSystem.guess_norb","text":"guess_norb(ms::MSys)\n\nGuess the number of orbitals in the system.\n\n\n\n\n\n","category":"function"},{"location":"elemco/#Calculations","page":"Calculations","title":"Calculations","text":"","category":"section"},{"location":"elemco/#Macros","page":"Calculations","title":"Macros","text":"","category":"section"},{"location":"elemco/","page":"Calculations","title":"Calculations","text":"@ECsetup\n@opt\n@dfhf\n@dfints\n@cc","category":"page"},{"location":"elemco/#ElemCo.@ECsetup","page":"Calculations","title":"ElemCo.@ECsetup","text":"@ECsetup()\n\nSetup EC::ECInfo from variables geometry::String and basis::Dict{String,Any}.\n\nExamples\n\ngeometry=\"\nHe 0.0 0.0 0.0\"\nbasis = Dict(\"ao\"=>\"cc-pVDZ\", \"jkfit\"=>\"cc-pvtz-jkfit\", \"mp2fit\"=>\"cc-pvdz-rifit\")\n@ECsetup\n# output\nOccupied orbitals:[1]\n\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@opt","page":"Calculations","title":"ElemCo.@opt","text":"@opt(what, kwargs...)\n\nSet options for EC::ECInfo. \n\nIf EC is not already setup, it will be done. \n\nExamples\n\n@opt scf thr=1.e-14 maxit=10\n@opt cc maxit=100\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@dfhf","page":"Calculations","title":"ElemCo.@dfhf","text":"@dfhf()\n\nRun DFHF calculation and return MO coefficients (ORBS) and orbital energies (EPS).\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@dfints","page":"Calculations","title":"ElemCo.@dfints","text":"@dfints(orbs = nothing, fcidump = \"\")\n\nGenerate 2 and 4-idx MO integrals using density fitting.\n\nIf orbs::Matrix is given, the orbitals are used to generate the integrals,    otherwise the last orbitals (ORBS) are used.   If fcidump::String is given, the integrals are written to the fcidump file.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@cc","page":"Calculations","title":"ElemCo.@cc","text":"@cc(method, kwargs...)\n\nRun coupled cluster calculation.\n\nThe type of the method is determined by the first argument (ccsd/ccsd(t)/dcsd etc)\n\nKeyword arguments\n\nfcidump::String: fcidump file (default: \"\", i.e., use integrals from EC).\nocca::String: occupied α orbitals (default: \"-\").\noccb::String: occupied β orbitals (default: \"-\").\n\nExamples\n\ngeometry=\"bohr\nO      0.000000000    0.000000000   -0.130186067\nH1     0.000000000    1.489124508    1.033245507\nH2     0.000000000   -1.489124508    1.033245507\"\nbasis = Dict(\"ao\"=>\"cc-pVDZ\", \"jkfit\"=>\"cc-pvtz-jkfit\", \"mp2fit\"=>\"cc-pvdz-rifit\")\n@dfhf\n@dfints\n@cc ccsd\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#Exported-functions","page":"Calculations","title":"Exported functions","text":"","category":"section"},{"location":"elemco/","page":"Calculations","title":"Calculations","text":"ECdriver","category":"page"},{"location":"elemco/#ElemCo.ECdriver","page":"Calculations","title":"ElemCo.ECdriver","text":"ECdriver(EC::ECInfo, methods; fcidump=\"FCIDUMP\", occa=\"-\", occb=\"-\")\n\nRun electronic structure calculation for EC::ECInfo using methods methods::String.\n\nThe integrals are read from fcidump::String (default: \"FCIDUMP\").   If fcidump::String is empty, the integrals from EC.fd are used.   The occupied α orbitals are given by occa::String (default: \"-\").   The occupied β orbitals are given by occb::String (default: \"-\").   If occb::String is empty, the occupied β orbitals are the same as the occupied α orbitals (closed-shell case).\n\n\n\n\n\n","category":"function"},{"location":"elemco/#Some-internal-functions","page":"Calculations","title":"Some internal functions","text":"","category":"section"},{"location":"elemco/","page":"Calculations","title":"Calculations","text":"ElemCo.parse_commandline\nElemCo.is_closed_shell\nElemCo.calc_HF_energy","category":"page"},{"location":"elemco/#ElemCo.parse_commandline","page":"Calculations","title":"ElemCo.parse_commandline","text":"parse_commandline(EC::ECInfo)\n\nParse command line arguments. \n\n\n\n\n\n","category":"function"},{"location":"elemco/#ElemCo.is_closed_shell","page":"Calculations","title":"ElemCo.is_closed_shell","text":"is_closed_shell(EC::ECInfo)\n\nCheck if the system is closed-shell    according the to the reference occupation and FCIDump.\n\n\n\n\n\n","category":"function"},{"location":"elemco/#ElemCo.calc_HF_energy","page":"Calculations","title":"ElemCo.calc_HF_energy","text":"calc_HF_energy(EC::ECInfo, closed_shell)\n\nCalculate HF energy from FCIDump and EC info. \n\n\n\n\n\n","category":"function"},{"location":"dfhf/#Density-fitted-Hartree-Fock","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"","category":"section"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"The density-fitted Hartree-Fock (DF-HF) method is a method for computing the Hartree-Fock energy using density fitting. The DF-HF method is implemented in ElemCo.jl using the @dfhf macro. Here's an example of how you can use this macro:","category":"page"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"using ElemCo\n\n# Define the molecule\ngeometry=\"bohr\n     O      0.000000000    0.000000000   -0.130186067\n     H1     0.000000000    1.489124508    1.033245507\n     H2     0.000000000   -1.489124508    1.033245507\"\n\nbasis = Dict(\"ao\"=>\"cc-pVDZ\",\n             \"jkfit\"=>\"cc-pvtz-jkfit\",\n             \"mp2fit\"=>\"cc-pvdz-rifit\")\n\n# Compute DF-HF\n@dfhf","category":"page"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"This code defines a water molecule, computes DF-HF using the cc-pVDZ basis set, and calculates the DF-HF energy.","category":"page"},{"location":"dfhf/#Exported-functions-and-types","page":"Density-fitted Hartree-Fock","title":"Exported functions and types","text":"","category":"section"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"ElemCo.dfhf","category":"page"},{"location":"dfhf/#ElemCo.DFHF.dfhf","page":"Density-fitted Hartree-Fock","title":"ElemCo.DFHF.dfhf","text":"dfhf(EC::ECInfo; direct=false, guess=:SAD)\n\nPerform closed-shell DF-HF calculation.\n\n\n\n\n\n","category":"function"},{"location":"cc/#Coupled-cluster-methods","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"","category":"section"},{"location":"cc/#Exported-functions","page":"Coupled-cluster methods","title":"Exported functions","text":"","category":"section"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"ElemCo.calc_MP2\nElemCo.calc_UMP2\nElemCo.method_name\nElemCo.calc_cc\nElemCo.calc_pertT","category":"page"},{"location":"cc/#ElemCo.CoupledCluster.calc_MP2","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_MP2","text":"calc_MP2(EC::ECInfo)\n\nCalculate closed-shell MP2 energy and amplitudes.    Return (EMp2, T2) \n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_UMP2","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_UMP2","text":"calc_UMP2(EC::ECInfo, addsingles=true)\n\nCalculate unrestricted MP2 energy and amplitudes.    Return (EMp2, T2a, T2b, T2ab)\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.method_name","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.method_name","text":"method_name(T1, dc=false)\n\nGuess method name (CCSD/DCSD/CCD/DCD)\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_cc","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_cc","text":"calc_cc(EC::ECInfo, T1, T2, dc = false)\n\nCalculate closed-shell coupled cluster amplitudes.\n\nIf length(T1) is 0 on input, no singles will be calculated. If dc: calculate distinguishable cluster.\n\n\n\n\n\ncalc_cc(EC::ECInfo, T1a, T1b, T2a, T2b, T2ab, dc = false)\n\nCalculate unrestricted coupled cluster amplitudes.\n\nIf length(T1a) && length(T1b) are 0 on input, no singles will be calculated.   If dc: calculate distinguishable cluster.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_pertT","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_pertT","text":"calc_pertT(EC::ECInfo, T1, T2; save_t3=false)\n\nCalculate (T) correction for closed-shell CCSD.\n\nReturn ( (T)-energy, [T]-energy))\n\n\n\n\n\n","category":"function"},{"location":"cc/#Some-internal-functions","page":"Coupled-cluster methods","title":"Some internal functions","text":"","category":"section"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"ElemCo.CoupledCluster.update_singles\nElemCo.CoupledCluster.update_doubles\nElemCo.CoupledCluster.calc_singles_energy\nElemCo.CoupledCluster.calc_doubles_energy\nElemCo.CoupledCluster.calc_hylleraas\nElemCo.CoupledCluster.calc_singles_norm\nElemCo.CoupledCluster.calc_doubles_norm\nElemCo.CoupledCluster.calc_dressed_ints\nElemCo.CoupledCluster.calc_D2\nElemCo.CoupledCluster.calc_D2a\nElemCo.CoupledCluster.calc_ccsd_resid","category":"page"},{"location":"cc/#ElemCo.CoupledCluster.update_singles","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.update_singles","text":"update_singles(R1, ϵo, ϵv, shift)\n\nCalculate update for singles amplitudes.\n\n\n\n\n\nupdate_singles(EC::ECInfo, R1; spincase::SpinCase=SCα, use_shift=true)\n\nCalculate update for singles amplitudes for a given spincase.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.update_doubles","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.update_doubles","text":"update_doubles(R2, ϵo1, ϵv1, ϵo2, ϵv2, shift)\n\nCalculate update for doubles amplitudes.\n\n\n\n\n\nupdate_doubles(EC::ECInfo, R2; spincase::SpinCase=SCα, antisymmetrize=false, use_shift=true)\n\nCalculate update for doubles amplitudes for a given spincase.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_singles_energy","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_singles_energy","text":"calc_singles_energy(EC::ECInfo, T1; fock_only=false)\n\nCalculate coupled-cluster closed-shell singles energy.\n\n\n\n\n\ncalc_singles_energy(EC::ECInfo, T1a, T1b; fock_only=false)\n\nCalculate energy for α (T1a) and β (T1b) singles amplitudes.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_doubles_energy","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_doubles_energy","text":"calc_doubles_energy(EC::ECInfo, T2; fock_only=false)\n\nCalculate coupled-cluster closed-shell doubles energy.\n\n\n\n\n\ncalc_doubles_energy(EC::ECInfo, T2a, T2b, T2ab; fock_only=false)\n\nCalculate energy for αα (T2a), ββ (T2b) and αβ (T2ab) doubles amplitudes.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_hylleraas","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_hylleraas","text":"calc_hylleraas(EC::ECInfo, T1, T2, R1, R2)\n\nCalculate closed-shell singles and doubles Hylleraas energy\n\n\n\n\n\ncalc_hylleraas(EC::ECInfo, T1a, T1b, T2a, T2b, T2ab, R1a, R1b, R2a, R2b, R2ab)\n\nCalculate singles and doubles Hylleraas energy.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_singles_norm","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_singles_norm","text":"calc_singles_norm(T1)\n\nCalculate squared norm of closed-shell singles amplitudes.\n\n\n\n\n\ncalc_singles_norm(T1a, T1b)\n\nCalculate squared norm of unrestricted singles amplitudes.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_doubles_norm","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_doubles_norm","text":"calc_doubles_norm(T2)\n\nCalculate squared norm of closed-shell doubles amplitudes.\n\n\n\n\n\ncalc_doubles_norm(T2a, T2b, T2ab)\n\nCalculate squared norm of unrestricted doubles amplitudes.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_dressed_ints","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_dressed_ints","text":"calc_dressed_ints(EC::ECInfo, T1, T12, o1::Char, v1::Char, o2::Char, v2::Char)\n\nDress integrals with singles amplitudes. \n\nThe singles and orbspaces for first and second electron are T1, o1, v1 and T12,o2,v2, respectively.   The integrals from EC.fd are used and dressed integrals are stored asd_????`.\n\n\n\n\n\ncalc_dressed_ints(EC::ECInfo, T1a, T1b=Float64[])\n\nDress integrals with singles.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_D2","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_D2","text":"calc_D2(EC::ECInfo, T1, T2, scalepp = false)\n\nCalculate D^ij_pq = T^ij_cd + T^i_c T^j_d +δ_ik T^j_d + T^i_c δ_jl + δ_ik δ_jl.   Return as D[pqij] \n\nIf scalepp: D[ppij] elements are scaled by 0.5 (for triangular summation).\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_D2a","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_D2a","text":"calc_D2a(EC::ECInfo, T1a, T2a)\n\nCalculate ^ααD^ij_pq = T^ij_cd + P_ij(T^i_c T^j_d +δ_ik T^j_d + T^i_c δ_jl + δ_ik δ_jl)   with P_ij X_ij = X_ij - X_ji.   Return as D[pqij] \n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_ccsd_resid","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ccsd_resid","text":"calc_ccsd_resid(EC::ECInfo, T1, T2, dc)\n\nCalculate CCSD or DCSD closed-shell residual.\n\n\n\n\n\ncalc_ccsd_resid(EC::ECInfo, T1a,T1b,T2a,T2b,T2ab,dc)\n\nCalculate UCCSD or UDCSD residual.\n\n\n\n\n\n","category":"function"},{"location":"options/#Options","page":"Options","title":"Options","text":"","category":"section"},{"location":"options/","page":"Options","title":"Options","text":"ElemCo.ECInfos.Options\nElemCo.ECInfos.ScfOptions\nElemCo.ECInfos.CcOptions\nElemCo.ECInfos.CholeskyOptions\nElemCo.ECInfos.DiisOptions","category":"page"},{"location":"options/#ElemCo.ECInfos.Options","page":"Options","title":"ElemCo.ECInfos.Options","text":"Options for ElemCo.jl\n\nscf:  SCF options.  Default: ScfOptions()\ncc:  Coupled-Cluster options.  Default: CcOptions()\ncholesky:  Cholesky options.  Default: CholeskyOptions()\ndiis:  DIIS options.  Default: DiisOptions()\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.ScfOptions","page":"Options","title":"ElemCo.ECInfos.ScfOptions","text":"Options for SCF calculation\n\nthr:  convergence threshold.  Default: 1.0e-10\nmaxit:  maximum number of iterations.  Default: 50\nimagtol:  tolerance for imaginary part of MO coefs (for biorthogonal).  Default: 1.0e-8\nguess:  orbital guess.  Default: :SAD\norbsguess:  orbitals for orbital guess.  Default: C_Am\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.CcOptions","page":"Options","title":"ElemCo.ECInfos.CcOptions","text":"Options for Coupled-Cluster calculation\n\nthr:  convergence threshold.  Default: 1.0e-10\nmaxit:  maximum number of iterations.  Default: 50\nshifts:  level shift for singles.  Default: 0.15\nshiftp:  level shift for doubles.  Default: 0.2\nshiftt:  level shift for triples.  Default: 0.2\nampsvdtol:  amplitude decomposition threshold.  Default: 0.001\nuse_kext:  use kext for doubles residual.  Default: true\ncalc_d_vvvv:  calculate dressed <vv|vv>.  Default: false\ncalc_d_vvvo:  calculate dressed <vv|vo>.  Default: false\ncalc_d_vovv:  calculate dressed <vo|vv>.  Default: false\ncalc_d_vvoo:  calculate dressed <vv|oo>.  Default: false\ntriangular_kext:  use a triangular kext if possible.  Default: true\ncalc_t3_for_decomposition:  calculate (T) for decomposition.  Default: false\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.CholeskyOptions","page":"Options","title":"ElemCo.ECInfos.CholeskyOptions","text":"Options for Cholesky decomposition.\n\nthr:  cholesky threshold.  Default: 1.0e-6\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.DiisOptions","page":"Options","title":"ElemCo.ECInfos.DiisOptions","text":"Options for DIIS.\n\nmaxdiis:  maximum number of DIIS vectors.  Default: 6\nresthr:  DIIS residual threshold.  Default: 10.0\n\n\n\n\n\n","category":"type"},{"location":"ecinfos/#ElemCo.jl-global-information","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"ElemCo.ECInfos.ECInfo\nElemCo.ECInfos.setup!\nElemCo.ECInfos.set_options!\nElemCo.ECInfos.parse_orbstring\nElemCo.ECInfos.get_occvirt","category":"page"},{"location":"ecinfos/#ElemCo.ECInfos.ECInfo","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.ECInfo","text":"ECInfo\n\nGlobal information for ElemCo.\n\nscr:  path to scratch directory.  Default: joinpath(tempdir(), \"elemcojlscr\")\next:  extension of temporary files.  Default: .bin\nout:  output file.  Default:\nverbosity:  verbosity level.  Default: 2\noptions:  options.  Default: Options()\nms:  molecular system.  Default: MSys()\nfd:  fcidump.  Default: FDump()\nfiles:  information about (temporary) files. The naming convention is: prefix_ + name (+extension EC.ext added automatically). prefix can be:\nd for dressed integrals\nS for overlap matrix\nf for Fock matrix\ne for orbital energies\nD for density matrix\nh for core Hamiltonian\nC for transformation from one basis to another\nname is given by the subspaces involved:\no for occupied\nv for virtual\nO for occupied-β\nV for virtual-β\nm for (full) MO space\nM for (full) β-MO space\nA for AO basis\na for active orbitals\nc for closed-shell (doubly-occupied) orbitals\nP for auxiliary orbitals (fitting basis)\nL for auxiliary orbitals (Cholesky decomposition, orthogonal)\nX for auxiliary orbitals (amplitudes decomposition)\nDefault: Dict{String, String}()\nignore_error:  ignore various errors.  Default: false\nspace:  subspaces: 'o'ccupied, 'v'irtual, 'O'ccupied-β, 'V'irtual-β, ':' general.  Default: Dict{Char, Any}()\n\n\n\n\n\n","category":"type"},{"location":"ecinfos/#ElemCo.ECInfos.setup!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.setup!","text":"setup!(EC::ECInfo; fcidump=\"\", occa=\"-\", occb=\"-\", nelec=0, charge=0, ms2=0)\n\nSetup ECInfo from fcidump or molecular system.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.set_options!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.set_options!","text":"set_options!(opt; kwargs...)\n\nSet options for option opt using keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.parse_orbstring","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.parse_orbstring","text":"parse_orbstring(orbs::String; orbsym = Vector{Int})\n\nParse a string specifying some list of orbitals, e.g.,    -3+5-8+10-12 → [1 2 3 5 6 7 8 10 11 12]   or use ':' and ';' instead of '-' and '+', respectively.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.get_occvirt","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.get_occvirt","text":"get_occvirt(EC::ECInfo, occas::String, occbs::String, norb, nelec; ms2=0, orbsym = Vector{Int})\n\nUse a +/- string to specify the occupation. If occbs==\"-\", the occupation from occas is used (closed-shell).   If both are \"-\", the occupation is deduced from nelec and ms2.   The optional argument orbsym is a vector with length norb of orbital symmetries (1 to 8) for each orbital.\n\n\n\n\n\n","category":"function"},{"location":"#ElemCo.jl-Documentation","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"","category":"section"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"ElemCo.jl is a Julia package for computing electronic structure properties of molecules and materials. It provides a set of tools for performing quantum chemical calculations, including Hartree-Fock and post-HF methods.","category":"page"},{"location":"#Installation","page":"ElemCo.jl Documentation","title":"Installation","text":"","category":"section"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"You can install ElemCo.jl using the Julia package manager:","category":"page"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"julia> using Pkg\njulia> Pkg.add(\"ElemCo\")","category":"page"},{"location":"#Usage","page":"ElemCo.jl Documentation","title":"Usage","text":"","category":"section"},{"location":"#Computing-density-fitted-Hartree-Fock-and-Coupled-Cluster-methods","page":"ElemCo.jl Documentation","title":"Computing density-fitted Hartree-Fock and Coupled Cluster methods","text":"","category":"section"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"To compute density-fitted Hartree-Fock (DF-HF) using ElemCo.jl, you can use the @dfhf macro. In order to run post-HF calculations, the integrals have to be transformed to the MO basis (using the @dfints macro), and the coupled cluster calculations can be performed using @cc macro. Here's an example of how you can use these macros:","category":"page"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"using ElemCo\n\n# Define the molecule\ngeometry=\"bohr\n     O      0.000000000    0.000000000   -0.130186067\n     H1     0.000000000    1.489124508    1.033245507\n     H2     0.000000000   -1.489124508    1.033245507\"\n\n\nbasis = Dict(\"ao\"=>\"cc-pVDZ\",\n             \"jkfit\"=>\"cc-pvtz-jkfit\",\n             \"mp2fit\"=>\"cc-pvdz-rifit\")\n\n# Compute DF-HF \n@dfhf\n# Calculate MO integrals \n@dfints\n# Run CCSD(T) calculation\n@cc ccsd(t)","category":"page"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"This code defines a water molecule, computes DF-HF using the cc-pVDZ basis set, calculates integrals using density fitting (mp2fit basis) and computes CCSD(T) energy.","category":"page"},{"location":"#Setting-options","page":"ElemCo.jl Documentation","title":"Setting options","text":"","category":"section"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"To set options for the DF-HF calculation, you can use the @opt macro. Here's an example of how you can use this macro:","category":"page"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"# Set the maximum number of iterations to 10\n@opt scf maxit=10\n\n# Compute DF-HF using the new options\n@dfhf","category":"page"},{"location":"","page":"ElemCo.jl Documentation","title":"ElemCo.jl Documentation","text":"This code sets the maximum number of iterations for the SCF procedure to 10 using the @opt macro, and then computes DF-HF using the new options using the @dfhf macro.","category":"page"}]
}
